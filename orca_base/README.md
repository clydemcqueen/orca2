# Orca Control Loop

## UKF predict step (in progress)

~~~
orca_filter/*
~~~

The UKF predict step projects the pose estimate from the previous sensor message forward to the time of the
most recent sensor message. 
The dt in these equations is the difference between the two sensor message timestamps.

## Trajectory planner and feedforward

~~~
orca_base/src/*segment*.cpp
~~~

The trajectory planner generates a planned (desired) pose at the time of the most recent sensor message.
The planner doesn’t care about the pose estimate.
The planner generates an acceleration that is used as feedforward in the controller.

## Motion equations

There are 2 sets of motion equations: a matrix-based set for the UKF and a hard-coded set in the trajectory planner.
Both sets model drag.
The trajectory planner only considers the 4 DoF that we can directly control with the thrusters: x, y, z and yaw.
The UKF considers all 6 DoF.

## Pose error

The pose error is the difference between the most recent pose estimate and the planned pose.
In theory the error includes the estimate covariance, but this is ignored for now.
Possible future work: use the covariance to attenuate the response to the pose error.

## PID controllers

~~~
orca_base/include/orca_base/pid.hpp
~~~

The most recent pose error is fed into the PID controllers, one for each control (x, y, z and yaw).
The result of each controller is u (control) at time t.
Orca interprets as u as acceleration, so the PID coefficients have the following units:
* Kp is 1 / s^2
* Ki is 1 / s^3
* Kd is 1 / s 

The output of the PID controllers is added to the feedforward generated by the planner to produce a total desired
acceleration for this timestep t.

The dt in the PID equation is the difference between the two sensor message timestamps.
You can run the controllers fast or slow -- it shouldn’t make a difference.
You can tune at one rate and run at a different rate -- it shouldn’t make a difference.

One caveat: drag makes PID tuning difficult.
In theory it’s important to do the tuning under a variety of drag situations, which means running the AUV with a
variety of velocities.
In practice it’s easier to tune and run the AUV with a single modest velocity, so that the drag effects are 
approximately zero.

The PID controllers work in the world frame.
It’s probably better to convert the pose error to the body frame and run the PID controllers in the body frame.
For z and yaw this has no effect, but presumably the PID coefficients for forward and strafe might be different, 
whereas the x and y PID coefficients are forced to be the same.
The bollard force is also assumed to be the same for forward and strafe, which might not be true.
This is possible future work.

## High-level controllers

~~~
orca_base/src/controller.cpp
~~~

The high-level controllers calculate the pose error and pass it to the 4 PID controllers.
They may do other pre- or post-processing to improve vehicle dynamics.

There are 5 high-level controllers: **(this section is out of date: there is 1 pose controller and 1 observation controller)**

The **IgnoreEstimateController** ignores the estimate completely.
Motion is dictated by the motion planner.

The **SimpleController** doesn’t do any pre- or post-processing.
There are no limits on the output, so PWM signals to the thrusters may vary rapidly and dramatically.
This may stress the ESCs and thrusters.

The **DeadzoneController** doesn’t call the PID controller if the error is small.
There are epsilons: a combined xy epsilon, z epsilon and yaw epsilon.
The feedforward is still applied.
The goal is to reduce the duty time of the thrusters.

The **JerkController** limits the jerk (rate of change of acceleration) generated by the PID controllers.
Feedforward is not affected.
The goal is to reduce the stress on the ESCs and thrusters.

The **BestController** combines the logic in the DeadzoneController and JerkController.

## Computing thrust efforts

Orca converts force and torque to ‘effort’ in the range [-1, 1] for each control using some notion of the maximum forces 
and torques that the thrusters can generate in unison.
These are very rough, and should be measured in the field.
The effort values are clamped to the range [-1, 1].

The 4 effort values are rotated into the body frame, then added in various combinations to generate the effort values 
for the 6 thrusters.
For the 4 horizontal thrusters it’s possible for the thruster efforts to fall outside the range [-1, 1], e.g., if the 
AUV is trying to rotate, move forward and move left all at the same time.
This is currently handled by combining forward and strafe thrust then clamping each thruster effort to ‘xy_limit’.
The yaw thrust is then added and each thruster is clamped again to [-1, 1].
This tends to favor the yaw motion over the forward and strafe motion (good), but the forward and strafe forces might 
be clamped per-thruster in odd ways, resulting in a wobbly motion (bad).
A better solution might be to add in all of the yaw force first, compute the amount of headroom left for forward 
and strafe, and attenuate them equally and add them in.
If velocities are low relative to thruster power this is moot.

## Sensor rates and the control loop

When we fuse sensors we combine the rates of all of the sensors.
Orca currently has one camera running at 30fps, but the plan is to have at least two 30 fps cameras (forward and down), 
one barometer and one IMU.
This will result in nominal sensor rates of 30 + 30 + 10 + 100 = 170Hz.
The actual sensor rate may vary: odometry may be lost on one or both cameras, 
queues may overflow and drop messages, etc.

Each sensor reading provides information, so it never makes sense to drop a sensor message on purpose.
The most accurate estimated pose is always the most recent output of the UKF.
Once the thrust efforts are computed it makes sense to send these to the driver immediately.
For all of these reasons it makes sense to run the control loop off the odometry message callback.

We do need a timer loop to manage startup tasks and timeouts.
The timer loop may also send control messages.

It’s possible that running the driver at 170Hz introduces problems that will have to be addressed during field testing.

## Translating effort to PWM

Thruster effort [-1.0, 1.0] is translated to PWM values [1100, 1900] by a simple linear scaling, with care taken 
so that effort 0.0 is precisely PWM 1500.
Orca uses BlueRobotics Basic ESC R3’s, so there’s no dead band.
The thrust curves aren’t perfectly linear, so this might be sub-optimal.

## Pololu Maestro

Orca uses a Pololu Maestro to send PWM messages to the ESCs.
The Maestro has nifty features to limit PWM value velocity and acceleration (which translates to jerk 
and pop in Orca-land), but these are turned off so the PWM is passed straight through.

## Gazebo simulation

The Gazebo simulation converts PWM to effort to force and torque per thruster, and applies the forces and 
torque to the Gazebo model at 1000Hz.
There are custom plug-ins to simulate drag and buoyancy, which applies additional forces to the Gazebo model.
The resulting simulation looks fairly reasonable.

## QoS, message queues, and threads

ROS2 can send messages 2 basic ways:
* service quality-of-service uses TCP packets and guarantees delivery
* sensor QoS uses UDP packages and a best-effort delivery mechanism

Orca uses service QoS for (almost) all topics because
1. these messages are logged
2. it's easier to debug the system when we expect every message to arrive

In the future we expect to move to sensor QoS for sensor messages.

Orca uses a message queue (history) of 10 for all topics.
A short queue -- combined with high callback latencies -- will drop messages.
This can cause timeouts to trip and can be difficult to debug.
The solution is to keep callback latencies short. Some examples:

* `annotate_image_node` subscribes to raw images, adds annotations, and publishes the annotated image.
The code was developed as part of `auv_node` and timing tests showed it never took more than 6ms, and
was typically around 1ms -- certainly fast enough.
However in some simulations (with a loaded CPU and a queue length of 1)
some control messages -- much more critical than annotated images -- were dropped.
Moving it to it's own node, with it's own thread, solved the problem.
I could have used a multi-thread executor, but moving this diagnostic to it's own node also
reduces complexity in the mission-critical `auv_node` code.
* `plot_auv_segments.py` listens to control messages, and when enough messages are accumulated
it builds and writes a set of graphs using `matplotlib`.
These plots were taking up to 2s. With a 20Hz message rate and a queue of 10 the node was dropping up
to 30 messages. The fix was to move the plotter to it's own Python thread so the callback is always fast.
* `auv_node` may decide to build a new local plan for every incoming sensor message. At the moment the
callback latency never exceeds 200us even if a new local plan is generated, so there is currently no reason to move
the planner to a separate thread.

## Timeouts

ArUco marker detection and pose generation can succeed or fail frame-by-frame, which means that some topics
will have abrupt stops and starts. Timeouts across multiple nodes must be calibrated:

* `image_raw` should be 30fps (33ms between messages). Same for `/forward_camera/camera_pose`, etc.
* `orca_filter` will wait 200ms (~6 frames) for a camera pose before switching to a depth filter
* `orca_filter` will wait 200ms (~6 frames) before resetting the filter due to rejected outliers
* `auv_node` will wait 300ms (~9 frames) before aborting the mission
* `driver_node` will wait 1s (~30 frames) before disabling the controller

**TODO update this section**

# Addendum

## Coordinate frames

ROS and Gazebo use the following conventions, which are carried over to Orca.
I mention them here because they are decidedly different than the maritime conventions.

* the world coordinate frame is ENU (East, North, Up)
* the body coordinate frame is Forward, Left, Up
* rotations follow the right hand rule
* everything is ISO (metric)

To avoid confusion a lot of code uses names like z and yaw instead of depth and heading.

The surface of the water is z=0.

Transformation naming conventions:
* t_destination_source is a transformation from source frame to destination frame
* xxx_f_destination means xxx is expressed in destination frame

Therefore:
* t_destination_source == source_f_destination
* t_a_c == t_a_b * t_b_c

## Modes

* Disarmed: thrusters are off, all joystick buttons except "arm" are ignored
* ROV: thrusters are manually controlled
* ROV hold z: the barometer and a simple PID controller is used to hold z position
* Mission (AUV) modes: Orca is running a mission, and will disarm when complete

## Motion model

Forces that Orca models:
* gravity
* buoyancy
* thruster translation forces
* vehicle drag

Thruster moments are not modeled, since the vehicle is designed to cancel thruster moments.

Tether drag is not modeled.
