# Orca Control Loop

## UKF predict step (in progress)

The UKF predict step projects the pose estimate from the previous sensor message forward to the time of the
most recent sensor message. 
The dt in these equations is the difference between the two sensor message timestamps.

## Trajectory planner and feedforward

The trajectory planner generates a planned (desired) pose at the time of the most recent sensor message.
The planner doesn’t care about the pose estimate.
The planner generates an acceleration that is used as feedforward in the controller.

## Motion equations

There are 2 sets of motion equations: a matrix-based set for the UKF and a hard-coded set in the trajectory planner.
Both sets model drag.
The trajectory planner only considers the 4 DoF that we can directly control with the thrusters: x, y, z and yaw.
The UKF considers all 6 DoF.

## Pose error

The pose error is the difference between the most recent pose estimate and the planned pose.
In theory the error includes the estimate covariance, but this is ignored for now.
Possible future work: use the covariance to attenuate the response to the pose error.

## PID controllers

The most recent pose error is fed into the PID controllers, one for each control (x, y, z and yaw).
The result of each controller is u (control) at time t.
We interpret as u as acceleration, so the PID coefficients have the following units:
* Kp is 1 / s^2
* Ki is 1 / s^3
* Kd is 1 / s 

The output of the PID controllers is added to the feedforward generated by the planner to produce a total desired
acceleration for this timestep t.

The dt in the PID equation is the difference between the two sensor message timestamps.
You can run the controllers fast or slow -- it shouldn’t make a difference.
You can tune at one rate and run at a different rate -- it shouldn’t make a difference.

One caveat: drag makes PID tuning difficult.
In theory it’s important to do the tuning under a variety of drag situations, which means running the AUV with a
variety of velocities.
In practice it’s easier to tune and run the AUV with a single modest velocity, so that the drag effects are 
approximately zero.

The PID controllers work in the world frame.
It’s probably better to convert the pose error to the body frame and run the PID controllers in the body frame.
For z and yaw this has no effect, but presumably the PID coefficients for forward and strafe might be different, 
whereas the x and y PID coefficients are forced to be the same.
The bollard force is also assumed to be the same for forward and strafe, which might not be true.
This is possible future work.

## High-level controllers

The high-level controllers calculate the pose error and pass it to the 4 PID controllers.
They may do other pre- or post-processing to improve vehicle dynamics.

There are 5 high-level controllers:

The **IgnoreEstimateController** ignores the estimate completely.
Motion is dictated by the motion planner.

The **SimpleController** doesn’t do any pre- or post-processing.
There are no limits on the output, so PWM signals to the thrusters may vary rapidly and dramatically.
This may stress the ESCs and thrusters.

The **DeadzoneController** doesn’t call the PID controller if the error is small.
There are epsilons: a combined xy epsilon, z epsilon and yaw epsilon.
The feedforward is still applied.
The goal is to reduce the duty time of the thrusters.

The **JerkController** limits the jerk (rate of change of acceleration) generated by the PID controllers.
Feedforward is not affected.
The goal is to reduce the stress on the ESCs and thrusters.

The **BestController** combines the logic in the DeadzoneController and JerkController.

## Computing thrust efforts

We convert force and torque to ‘effort’ in the range [-1, 1] for each control using some notion of the maximum forces 
and torques that the thrusters can generate in unison.
These are very rough, and should be measured in the field.
The effort values are clamped to the range [-1, 1].

The 4 effort values are rotated into the body frame, then added in various combinations to generate the effort values 
for the 6 thrusters.
For the 4 horizontal thrusters it’s possible for the thruster efforts to fall outside the range [-1, 1], e.g., if the 
AUV is trying to rotate, move forward and move left all at the same time.
This is currently handled by combining forward and strafe thrust then clamping each thruster effort to ‘xy_limit’.
The yaw thrust is then added and each thruster is clamped again to [-1, 1].
This tends to favor the yaw motion over the forward and strafe motion (good), but the forward and strafe forces might 
be clamped per-thruster in odd ways, resulting in a wobbly motion (bad).
A better solution might be to add in all of the yaw force first, compute the amount of headroom left for forward 
and strafe, and attenuate them equally and add them in.
If velocities are low relative to thruster power this is moot.

Orca doesn’t completely ignore the roll and pitch estimate: they are used to compute a ‘stability’ value, and this 
value is used to attenuate all 6 thrust efforts.
If stability falls below a certain threshold the control loop disarms the AUV altogether.

## Sensor rates and the control loop

When we fuse sensors we combine the rates of all of the sensors.
Orca currently has one camera running at 30fps, but the plan is to have two 30 fps cameras (forward and down), 
one barometer and one IMU.
This will result in nominal sensor rates of 30 + 30 + 10 + 100 = 170Hz.
The actual sensor rate may vary: odometry may be lost on one or both cameras, 
queues may overflow and drop messages, etc.

Each sensor reading provides information, so it never makes sense to drop a sensor message on purpose.
The most accurate estimated pose is always the most recent output of the UKF.
Once the thrust efforts are computed it makes sense to send these to the driver immediately.
For all of these reasons it makes sense to run the control loop off the odometry message callback.

We do need a timer loop to manage startup tasks and timeouts.
The timer loop may also send control messages.

It’s possible that running the driver at 170Hz introduces problems that will have to be addressed during field testing.

## Translating effort to PWM

Thruster effort [-1.0, 1.0] is translated to PWM values [1100, 1900] by a simple linear scaling, with care taken 
so that effort 0.0 is precisely PWM 1500.
Orca uses BlueRobotics Basic ESC R3’s, so there’s no dead band.
The thrust curves aren’t perfectly linear, so this might be sub-optimal.

## Pololu Maestro

Orca uses a Pololu Maestro to send PWM messages to the ESCs.
The Maestro has nifty features to limit PWM value velocity and acceleration (which translates to jerk 
and pop in Orca-land), but these are turned off so the PWM is passed straight through.

## Gazebo simulation

The Gazebo simulation converts PWM to effort to force and torque per thruster, and applies the forces and 
torque to the Gazebo model at 1000Hz.
There are custom plug-ins to simulate drag and buoyancy, which applies additional forces to the Gazebo model.
The resulting simulation looks fairly reasonable.

# Addendum

## Coordinate frames

ROS and Gazebo use the following conventions, which are carried over to Orca.
I mention them here because they are decidedly different than the maritime conventions.

* the world coordinate frame is ENU (East, North, Up)
* the body coordinate frame is Forward, Left, Up
* rotations follow the right hand rule
* everything is ISO (metric)

To avoid confusion the code uses names like z and yaw instead of depth and heading.

The surface of the water is z=0.

Transformation naming conventions:
* t_destination_source is a transformation from source frame to destination frame
* xxx_f_destination means xxx is expressed in destination frame

Therefore:
* t_destination_source == source_f_destination
* t_a_c == t_a_b * t_b_c

## Modes

* Disarmed: thrusters are off, all joystick buttons except "arm" are ignored
* ROV: thrusters are manually controlled
* ROV hold z: the barometer and a simple PID controller is used to hold z position
* Mission (AUV) modes: Orca is running a mission, and will disarm when complete

## Motion model

Forces that we model:
* gravity
* buoyancy
* thruster translation forces
* vehicle drag

Thruster moments are not modeled, since the vehicle is designed to cancel thruster moments.

Tether drag is not modeled.
